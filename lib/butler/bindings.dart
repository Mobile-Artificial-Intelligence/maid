// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int butler_start(
    ffi.Pointer<butler_params> butler,
  ) {
    return _butler_start(
      butler,
    );
  }

  late final _butler_startPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<butler_params>)>>(
          'butler_start');
  late final _butler_start =
      _butler_startPtr.asFunction<int Function(ffi.Pointer<butler_params>)>();

  int butler_continue(
    ffi.Pointer<ffi.Char> input,
    ffi.Pointer<maid_output_cb> maid_output,
  ) {
    return _butler_continue(
      input,
      maid_output,
    );
  }

  late final _butler_continuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<maid_output_cb>)>>('butler_continue');
  late final _butler_continue = _butler_continuePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<maid_output_cb>)>();

  void butler_stop() {
    return _butler_stop();
  }

  late final _butler_stopPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('butler_stop');
  late final _butler_stop = _butler_stopPtr.asFunction<void Function()>();

  void butler_exit() {
    return _butler_exit();
  }

  late final _butler_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('butler_exit');
  late final _butler_exit = _butler_exitPtr.asFunction<void Function()>();
}

final class butler_params extends ffi.Struct {
  @ffi.UnsignedChar()
  external int instruct;

  @ffi.UnsignedChar()
  external int interactive;

  @ffi.UnsignedChar()
  external int memory_f16;

  external ffi.Pointer<ffi.Char> model_path;

  external ffi.Pointer<ffi.Char> preprompt;

  external ffi.Pointer<ffi.Char> input_prefix;

  external ffi.Pointer<ffi.Char> input_suffix;

  @ffi.UnsignedInt()
  external int seed;

  @ffi.Int()
  external int n_ctx;

  @ffi.Int()
  external int n_batch;

  @ffi.Int()
  external int n_threads;

  @ffi.Int()
  external int n_threads_batch;

  @ffi.Int()
  external int n_predict;

  @ffi.Int()
  external int n_keep;

  @ffi.Int()
  external int n_prev;

  @ffi.Int()
  external int n_probs;

  @ffi.Int()
  external int top_k;

  @ffi.Float()
  external double top_p;

  @ffi.Float()
  external double tfs_z;

  @ffi.Float()
  external double typical_p;

  @ffi.Float()
  external double temp;

  @ffi.Int()
  external int penalty_last_n;

  @ffi.Float()
  external double penalty_repeat;

  @ffi.Float()
  external double penalty_freq;

  @ffi.Float()
  external double penalty_present;

  @ffi.Int()
  external int mirostat;

  @ffi.Float()
  external double mirostat_tau;

  @ffi.Float()
  external double mirostat_eta;

  @ffi.UnsignedChar()
  external int penalize_nl;
}

abstract class return_code {
  static const int STOP = 0;
  static const int CONTINUE = 1;
}

typedef maid_output_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.UnsignedChar code, ffi.Pointer<ffi.Char> buffer)>;
